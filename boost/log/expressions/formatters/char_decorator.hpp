/*
 *          Copyright Andrey Semashev 2007 - 2012.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
/*!
 * \file   formatters/char_decorator.hpp
 * \author Andrey Semashev
 * \date   17.11.2012
 *
 * The header contains implementation of a character decorator.
 */

#ifndef BOOST_LOG_EXPRESSIONS_FORMATTERS_CHAR_DECORATOR_HPP_INCLUDED_
#define BOOST_LOG_EXPRESSIONS_FORMATTERS_CHAR_DECORATOR_HPP_INCLUDED_

#include <vector>
#include <string>
#include <utility>
#include <boost/assert.hpp>
#include <boost/static_assert.hpp>
#include <boost/mpl/bool.hpp>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/range/value_type.hpp>
#include <boost/phoenix/core/actor.hpp>
#include <boost/phoenix/core/meta_grammar.hpp>
#include <boost/phoenix/core/terminal_fwd.hpp>
#include <boost/phoenix/core/is_nullary.hpp>
#include <boost/phoenix/core/environment.hpp>
#include <boost/fusion/sequence/intrinsic/at_c.hpp>
#include <boost/type_traits/is_same.hpp>
#include <boost/type_traits/remove_cv.hpp>
#include <boost/type_traits/remove_reference.hpp>
#include <boost/log/detail/prologue.hpp>
#include <boost/log/detail/custom_terminal_spec.hpp>
#include <boost/log/detail/deduce_char_type.hpp>

#ifdef BOOST_LOG_HAS_PRAGMA_ONCE
#pragma once
#endif

namespace boost {

BOOST_LOG_OPEN_NAMESPACE

namespace expressions {

namespace aux {

template< typename CharT >
class char_decorator_base
{
public:
    //! Character type
    typedef CharT char_type;
    //! String type
    typedef std::basic_string< char_type > string_type;

private:
    //! List of the decorations to apply
    typedef std::vector< std::pair< string_type, string_type > > decorations_list;

private:
    //! List of the decorations to apply
    decorations_list m_decorations;

public:
    /*!
     * Initializing constructor. Creates decorator of the \a fmt formatter with the specified \a decorations.
     */
    template< typename RangeT >
    explicit char_decorator_base(RangeT const& decorations) :
        m_decorations(begin(decorations), end(decorations))
    {
    }
    /*!
     * Initializing constructor. Creates decorator of the \a fmt formatter with decorations specified
     * in form of two same-sized string sequences. Each <tt>i</tt>'th decoration will be
     * <tt>from[i]</tt> -> <tt>to[i]</tt>.
     */
    template< typename FromRangeT, typename ToRangeT >
    char_decorator_base(FromRangeT const& from, ToRangeT const& to)
    {
        typedef typename decorations_list::value_type value_type;
        typedef typename range_const_iterator< FromRangeT >::type iterator1;
        typedef typename range_const_iterator< ToRangeT >::type iterator2;
        iterator1 it1 = begin(from), end1 = end(from);
        iterator2 it2 = begin(to), end2 = end(to);
        for (; it1 != end1 && it2 != end2; ++it1, ++it2)
        {
            m_decorations.push_back(value_type(*it1, *it2));
        }

        // Both sequences should be of the same size
        BOOST_ASSERT(it1 == end1);
        BOOST_ASSERT(it2 == end2);
    }
    //! Copy constructor
    char_decorator_base(char_decorator_base const& that) : m_decorations(that.m_decorations)
    {
    }

protected:
    //! Applies string replacements
    void apply_decorations(string_type& str, typename string_type::size_type start_pos) const
    {
        typedef typename string_type::size_type size_type;

        for (typename decorations_list::const_iterator it = m_decorations.begin(), end = m_decorations.end(); it != end; ++it)
        {
            for (size_type pos = str.find(it->first, start_pos); pos != string_type::npos; pos = str.find(it->first, pos))
            {
                str.replace(pos, it->first.size(), it->second);
                pos += it->second.size();
            }
        }
    }
};

} // namespace aux

/*!
 * Character decorator terminal class. This formatter allows to modify strings generated by other
 * formatters on character level. The most obvious application of decorators is replacing
 * a certain set of characters with decorated equivalents to satisfy requirements of
 * text-based sinks.
 *
 * The \c char_decorator_terminal class aggregates the formatter being decorated, and a set
 * of string pairs that are used as decorations. All decorations are applied sequentially.
 * The \c char_decorator_terminal class is a formatter itself, so it can be used to construct
 * more complex formatters, including nesting decorators.
 */
template< typename SubactorT, typename CharT >
class char_decorator_terminal :
    public aux::char_decorator_base< CharT >
{
private:
    //! Self type
    typedef char_decorator_terminal< SubactorT, CharT > this_type;
    //! Base type
    typedef aux::char_decorator_base< CharT > base_type;

public:
    //! Internal typedef for type categorization
    typedef void _is_boost_log_terminal;

    //! Character type
    typedef typename base_type::char_type char_type;
    //! String type
    typedef typename base_type::string_type string_type;
    //! Adopted actor type
    typedef SubactorT subactor_type;

    //! Result type definition
    template< typename >
    struct result;

    template< typename ContextT >
    struct result< this_type(ContextT) >
    {
        typedef typename remove_cv< typename remove_reference< ContextT >::type >::type context_type;
        typedef typename phoenix::evaluator::impl<
            typename subactor_type::proto_base_expr&,
            context_type,
            phoenix::unused
        >::result_type type;
    };

    template< typename ContextT >
    struct result< const this_type(ContextT) >
    {
        typedef typename remove_cv< typename remove_reference< ContextT >::type >::type context_type;
        typedef typename phoenix::evaluator::impl<
            typename subactor_type::proto_base_expr const&,
            context_type,
            phoenix::unused
        >::result_type type;
    };

private:
    //! Adopted formatter actor
    subactor_type m_subactor;

public:
    /*!
     * Initializing constructor. Creates decorator of the \a fmt formatter with the specified \a decorations.
     */
    template< typename RangeT >
    char_decorator_terminal(subactor_type const& sub, RangeT const& decorations) : base_type(decorations), m_subactor(sub)
    {
    }
    /*!
     * Initializing constructor. Creates decorator of the \a fmt formatter with decorations specified
     * in form of two same-sized string sequences. Each <tt>i</tt>'th decoration will be
     * <tt>from[i]</tt> -> <tt>to[i]</tt>.
     */
    template< typename FromRangeT, typename ToRangeT >
    char_decorator_terminal(subactor_type const& sub, FromRangeT const& from, ToRangeT const& to) : base_type(from, to), m_subactor(sub)
    {
    }
    /*!
     * Copy constructor
     */
    char_decorator_terminal(char_decorator_terminal const& that) : base_type(static_cast< base_type const& >(that)), m_subactor(that.m_subactor)
    {
    }

    /*!
     * Invokation operator
     */
    template< typename ContextT >
    typename result< this_type(ContextT const&) >::type operator() (ContextT const& ctx)
    {
        // Flush the stream and keep the current write position in the target string
        typedef typename remove_cv<
            typename remove_reference< typename phoenix::result_of::env< ContextT const& >::type >::type
        >::type env_type;
        typedef typename env_type::args_type args_type;
        typedef typename fusion::result_of::at_c< args_type, 1 >::type stream_arg_type;

        stream_arg_type strm = fusion::at_c< 1 >(phoenix::env(ctx).args());
        strm.flush();
        typename string_type::size_type const start_pos = strm.rdbuf()->storage()->size();

        // Invoke the adopted formatter
        typedef typename result< this_type(ContextT const&) >::type result_type;
        result_type res = phoenix::eval(m_subactor, ctx);

        // Flush the buffered characters and apply decorations
        strm.flush();
        this->apply_decorations(*strm.rdbuf()->storage(), start_pos);

        return res;
    }

    /*!
     * Invokation operator
     */
    template< typename ContextT >
    typename result< const this_type(ContextT const&) >::type operator() (ContextT const& ctx) const
    {
        // Flush the stream and keep the current write position in the target string
        typedef typename remove_cv<
            typename remove_reference< typename phoenix::result_of::env< ContextT const& >::type >::type
        >::type env_type;
        typedef typename env_type::args_type args_type;
        typedef typename fusion::result_of::at_c< args_type, 1 >::type stream_arg_type;

        stream_arg_type strm = fusion::at_c< 1 >(phoenix::env(ctx).args());
        strm.flush();
        typename string_type::size_type const start_pos = strm.rdbuf()->storage()->size();

        // Invoke the adopted formatter
        typedef typename result< const this_type(ContextT const&) >::type result_type;
        result_type res = phoenix::eval(m_subactor, ctx);

        // Flush the buffered characters and apply decorations
        strm.flush();
        this->apply_decorations(*strm.rdbuf()->storage(), start_pos);

        return res;
    }
};

namespace aux {

template< typename RangeT >
class char_decorator_gen1
{
    RangeT const& m_decorations;

    typedef typename boost::log::aux::deduce_char_type< typename range_value< RangeT >::type::first_type >::type char_type;

public:
    explicit char_decorator_gen1(RangeT const& decorations) : m_decorations(decorations)
    {
    }

    template< typename SubactorT >
    BOOST_LOG_FORCEINLINE phoenix::actor< char_decorator_terminal< SubactorT, char_type > > operator[] (SubactorT const& subactor) const
    {
        typedef char_decorator_terminal< SubactorT, char_type > terminal_type;
        phoenix::actor< terminal_type > act = {{ terminal_type(subactor, m_decorations) }};
        return act;
    }
};

template< typename FromRangeT, typename ToRangeT >
class char_decorator_gen2
{
    FromRangeT const& m_from;
    ToRangeT const& m_to;

    typedef typename boost::log::aux::deduce_char_type< typename range_value< FromRangeT >::type >::type from_char_type;
    typedef typename boost::log::aux::deduce_char_type< typename range_value< ToRangeT >::type >::type to_char_type;
    BOOST_STATIC_ASSERT_MSG((is_same< from_char_type, to_char_type >::value), "Boost.Log: character decorator cannot be instantiated with different character types for source and replacement strings");

public:
    char_decorator_gen2(FromRangeT const& from, ToRangeT const& to) : m_from(from), m_to(to)
    {
    }

    template< typename SubactorT >
    BOOST_LOG_FORCEINLINE phoenix::actor< char_decorator_terminal< SubactorT, from_char_type > > operator[] (SubactorT const& subactor) const
    {
        typedef char_decorator_terminal< SubactorT, from_char_type > terminal_type;
        phoenix::actor< terminal_type > act = {{ terminal_type(subactor, m_from, m_to) }};
        return act;
    }
};

} // namespace aux

/*!
 * The function returns a decorator generator object. The generator provides <tt>operator[]</tt> that can be used
 * to construct the actual decorator.
 *
 * \param decorations A sequence of string pairs that will be used as decorations. Every <tt>decorations[i].first</tt>
 *                    substring occurrence in the output will be replaced with <tt>decorations[i].second</tt>.
 */
template< typename RangeT >
BOOST_LOG_FORCEINLINE aux::char_decorator_gen1< RangeT > char_dec(RangeT const& decorations)
{
    return aux::char_decorator_gen1< RangeT >(decorations);
}

/*!
 * The function returns a decorator generator object. The generator provides <tt>operator[]</tt> that can be used
 * to construct the actual decorator.
 *
 * \param from A sequence of strings that will be sought in the output.
 * \param to A sequence of strings that will be used as replacements.
 *
 * \note The \a from and \a to sequences mush be of the same size. Every <tt>from[i]</tt>
 *       substring occurrence in the output will be replaced with <tt>to[i]</tt>.
 */
template< typename FromRangeT, typename ToRangeT >
BOOST_LOG_FORCEINLINE aux::char_decorator_gen2< FromRangeT, ToRangeT > char_dec(FromRangeT const& from, ToRangeT const& to)
{
    return aux::char_decorator_gen2< FromRangeT, ToRangeT >(from, to);
}

} // namespace expressions

BOOST_LOG_CLOSE_NAMESPACE // namespace log

#ifndef BOOST_LOG_DOXYGEN_PASS

namespace phoenix {

namespace result_of {

template< typename SubactorT, typename CharT >
struct is_nullary< custom_terminal< boost::log::expressions::char_decorator_terminal< SubactorT, CharT > > > :
    public mpl::false_
{
};

} // namespace result_of

} // namespace phoenix

#endif

} // namespace boost

#endif // BOOST_LOG_EXPRESSIONS_FORMATTERS_CHAR_DECORATOR_HPP_INCLUDED_
